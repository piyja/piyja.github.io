<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="https://pjcha.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://pjcha.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2024-03-09T14:30:47+00:00</updated><id>https://pjcha.github.io/feed.xml</id><title type="html">blank</title><entry><title type="html">Book Review Fundamentals Software Architecture</title><link href="https://pjcha.github.io/blog/2024/Book-review-Fundamentals-Software-Architecture/" rel="alternate" type="text/html" title="Book Review Fundamentals Software Architecture"/><published>2024-03-09T00:20:00+00:00</published><updated>2024-03-09T00:20:00+00:00</updated><id>https://pjcha.github.io/blog/2024/Book-review-Fundamentals-Software-Architecture</id><content type="html" xml:base="https://pjcha.github.io/blog/2024/Book-review-Fundamentals-Software-Architecture/"><![CDATA[<h1 id="why-did-i-pick-this-book">Why did I pick this book?</h1> <p>Coming from a product design background and writing software in embedded products, my curiosity drives me to go beyond software design and development layers. Just like any hardware-based product, software products are an amalgamation of different software principles. This natural curve opened an opportunity for me to take on architectural tasks within the scope of my development activities. Offlate I have been getting involved at the system level components and piecing out the different information points into the system architecture. To take this further into streamlined learning, it is impossible to not stumble upon this book.</p> <p>In the following part of this article, I have tried to give you a brief introduction to the book and give you my personal learnings from it. This article is purely for academic purposes and is part of my contribution to the software community world. If this interests you I would highly recommend reading the book further.</p> <h1 id="structure-of-the-book">Structure of the book</h1> <p>This book is written in three independent sections to cover the holistic view of software architecture.<br/> <em>Part I</em>: Covers the foundation of the software architecture, defining it and breaking it down into its core blocks. It also covers means of identifying, measuring, and governing architectural characteristics.<br/> <em>Part II</em>: Here it covers different architectural designs and assessment of the characteristics of it in star rating format.<br/> <em>Part III</em>: Then it talks about recording architectural decisions - on useful methods and tools to do it. The author also speaks about the usefulness of soft skills to do the job of an architect.</p> <p>Following are the key highlights I have noted and written in my words.</p> <h1 id="what-software-architecture-is-about">What software architecture is about?</h1> <h2 id="defining-the-architecture">Defining the architecture</h2> <p>On the same lines of Martin Fowler’s definition in his famous article <a href="https://martinfowler.com/ieeeSoftware/whoNeedsArchitect.pdf">“Who needs an architect”</a> quoted “Software Architecture is about the important stuff, whatever that is”, the authors re-enforces this and has made an excellent attempt to explains us to why that is true. In the age of the programming world, software architecture has a constantly evolving role and hence its definition. In the most general terms, it can be equivalent to understanding the system which is divided into its components and connected with interfaces. As the authors quoted</p> <blockquote> <p>It is the highest level concept of the expert developers and their shared understanding The focus of software architecture should be more on the <code class="language-plaintext highlighter-rouge">WHY</code> than the <code class="language-plaintext highlighter-rouge">HOW</code> part.</p> </blockquote> <h2 id="software-architectures-4-sides">Software architecture’s 4 sides</h2> <p>The designing process of an effective piece of software can be further split into following steps:</p> <ul> <li>Structure - The base technology stack which forms the structural part of your software</li> <li>Characteristics - The technological properties which want your software to bring across</li> <li>Decisions - The decision tree which led to final software product</li> <li>Design principles - The principles which were closely followed while development</li> </ul> <p>The authors have provided easy to understand pictorial depictions for the above point which is helpfully embossing.</p> <h3 id="architectural-thinking---broadening-the-breadth">Architectural thinking - broadening the breadth</h3> <p>A developer’s mindset is to dig deeper into few chosen / relevant topics, while an architect needs to have an overview on a range of different technologies. Surely an architect needs to know a few topics well in depth but the part where they start making the difference is having an overview of the technologies used in the product.</p> <h4 id="defining-architectural-characteristics">Defining architectural characteristics</h4> <p>There are two types of architecture characteristics - explicit and implicit. Explicit characteristics are the ones which directly surface based on the solution provided and are non-domain specific design considerations. On the other hand implicit characteristics are the ones which are influenced from the structural aspects of the designs and are generally related to the domain specific knowledge. Let us take an example of designing a website for an online ticket booking system - here the characteristics such as reliability, availability, performance, scalability, etc. are explicitly covered while aspects such extensibility, upgradability, privacy, security etc. could be classified as implicit. I agree it is not 100% clear on how to label the characteristics, but the important point is to think from the perspective of the difference in domains and non-domain related characteristics.</p> <h4 id="identifying-architectural-characteristics-in-a-given-use-case">Identifying architectural characteristics in a given use case</h4> <p>One of the initial steps while architecting is to identify the characteristics. They can be extracted from the domain knowledge and the requirement documents. There is no specific set of rules to follow while identifying them, but one can practice through architectural Kata exercises.</p> <h4 id="measuring-and-governing-these-characteristics"><strong>Measuring</strong> and <strong>Governing</strong> these characteristics</h4> <p>Authors show us the importance of measuring the measurable characteristics as a means of justifying your decisions. Authors introduced techniques to measure characteristics of modularity via cohesion, coupling and connascence properties. This would help quantify the characteristics which sets a good platform for comparing decisions. For effective decision-making it is important to analyse the detailed output and form fitness functions. From these reports an architect gets the opportunity to govern the decision-making process.</p> <h4 id="component-based-thinking---conways-law">Component based thinking - Conways Law</h4> <p>Conways Law suggests that the organisation’s communication structure heavily influences the design structure of the product it is developing. The flow of information in an organisation is affected by how the teams are structured which then affects the decision-making process. Based on the decision the ownership of the different building blocks aka components are influenced and hence the overall design structure gets altered. As Martin Fowler mentioned there are three ways to deal with this law:</p> <ol> <li>Ignore - it is proven to be ineffective to fight against it</li> <li>Accept - make sure your architecture incorporates the designers communications pattern</li> <li>Inverse Conway Maneuver - make changes in the communication patterns to achieve design architecture</li> </ol> <p>The identification of the software components of a product can be done either based on technical or domain related. It is important to understand both divisions inorder to make knowledgeable trade off decision.</p> <h3 id="brief-introductions-into-the-architectural-patterns">Brief introductions into the architectural patterns</h3> <p>The author covered detailed definitions, descriptions and purpose of the various architectural designs. The designs covered are the following -</p> <ul> <li>Big ball of mud</li> <li>Monolithic architecture</li> <li>Component based design</li> <li>Service oriented architecture</li> <li>Service defined architecture</li> <li>Microservices</li> <li>Space based architecture</li> </ul> <p>I will not go further into the design patterns in this article as it will not do the justice to all of them in a short article. But if you are interested to know further I encourage reading up further in the book or other resources. The interesting part for me was the comparison which was made on all the designs. The following mentioned architectural characteristics are used as the comparison point namely - Deployability, Elasticity, Evolutionary, Fault tolerance, Modularity, Cost, Performance, Reliability, Scalability, Simplicity and Testability.</p> <h2 id="techniques-for-practicing-architecture">Techniques for practicing architecture</h2> <h4 id="practicing-with-architectural-katas">Practicing with Architectural Katas</h4> <p>To become a good architect one needs to practice making architects designs. In the beginning of my journey into this I struggled to find platforms to exercise architecture and the decision making process. This book introduces the concept of architectural katas, a concept originally formed by <a href="https://www.architecturalkatas.com/">Ted Neward</a>. It is an exercise where a bunch of enthusiasts come together to design a different system and a moderator who not only assigns the tasks but also keeps track of the time. I plan to organise such events in the near future, <ins>so if you are interested do drop a message below</ins>.</p> <h4 id="architectural-decisions-records">Architectural Decisions Records</h4> <p>Logging architectural decisions enables people from an organisation to take further design decisions abiding to the agreed ones. It allows to have a place where one can fallback for referring to the previous decisions taken and get away from <a href="https://softwarearchitecturezen.blog/2010/01/27/architecture-anti-patterns-pattern-1-architecture-by-e-mail/">email driven architectural decisions</a>. To create a high level understanding, it is mandatory to refer to the older superseded decisions while creating new decisions. Having a standard template for such decisions helps to create standardised records. There are various <a href="https://github.com/npryce/adr-tools">open source tools</a> to help align the ADRs process and become coherent with the software development process. Records could also include diagrams created with UMLs to convey the idea effectively.</p> <h4 id="developing-your-unique-architectural-path">Developing your unique Architectural path</h4> <p>Becoming an effective architect is a time consuming process and requires detailed path planning. In the final concluding chapter the authors gave us useful tips on laying down the path to become an architect. Everybody’s path to become an architect is a unique one and hence there are no specific rules for it. Author suggested creating a personalised radar for the technologies we are interested in and to pay close attention to the developments in it.</p> <p>Hope this article gives you a good insight into the book and what it has to offer.</p>]]></content><author><name></name></author><category term="Architecture"/><category term="books"/><category term="Book-reviews,"/><category term="Architecture,"/><category term="Design"/><summary type="html"><![CDATA[Book review for Fundamentals of Software Architecture - Mark Richards and Neal Ford]]></summary></entry><entry><title type="html">Book Review For C++ Design Pattern</title><link href="https://pjcha.github.io/blog/2024/Book-review-for-C++-Design-pattern/" rel="alternate" type="text/html" title="Book Review For C++ Design Pattern"/><published>2024-01-11T00:20:00+00:00</published><updated>2024-01-11T00:20:00+00:00</updated><id>https://pjcha.github.io/blog/2024/Book-review-for-C++-Design-pattern</id><content type="html" xml:base="https://pjcha.github.io/blog/2024/Book-review-for-C++-Design-pattern/"><![CDATA[<h1 id="about-the-book">About the book</h1> <p>Recently I got an opportunity to read C++ Software Design by Dr Klaus Iglberger. I find the concepts presented in the book if not to cover basics but quite intriguing to further the thought process. As a software developer, I do regularly of think of design patterns and use them aiming to make the codebase more modular, scalable, reusable, less coupled. Albeit I found a holistic view of the design patterns from this book and would recommend it to a seasoned software developer. In this post, I am aiming to give a summary of the book but it is not a promotional blog by any means. You can treat it as a nonexhaustive abstract of what the book covers but if you are intrigued more please dive into the book.</p> <p>The book is about 400 pages and is divided into 39 digestible guidelines. In my opinion, the best part about this book is the footnotes and further reading material the author provides us. If you have attended/heard Dr Klaus’s talks you can imagine his voice while reading the book. The author writes a lot about readers’ reactive comments while introducing the concepts, which might annoy few but also helps in covering all-around discussions on it. After going through some pages you can even anticipate when these takes are coming ;-)</p> <p>Alright, let’s dive in. Following are the sections giving the summary of the book.</p> <h1 id="13-basic-software-development-principles-and-what-they-mean-from-architectural-pov">[1/3] Basic Software Development principles and what they mean from architectural pov</h1> <p>In this first part of the book, the author introduces both what software design is and why it is important in any software project. If we go to the first principle it is nothing but the “Art of managing dependencies and abstraction”. The author represents software development in three levels of</p> <ol> <li>Software architecture</li> <li>Software design</li> <li>Implementation details</li> </ol> <p>and explains the differences in the architecture and design of the software. The author gives us a helpful perspective to look at any software designs, ie from high level (fairly stable) and low level (prone to change).</p> <p>The author emphasizes how <strong>change is constant</strong> and <strong>design for extension</strong> and we developers should persistently keep this in the back of our minds. The author covers the most famous software principles like SOLID, DRY, ISP (and many more) but more importantly there are discusssions on how to interpret these principles while creating the low-level designs of the software. Most of his takes boils down to a single aspect while creating the designs to think about the “separation of concerns”. Separation of concerns sits at the base for most of the design patterns, if I were to zoom into it further, separations of concerns can be thought of from these two lenses -</p> <ol> <li>Decreasing coupling (be it artificial coupling)</li> <li>Increasing cohesion</li> </ol> <p>The section <strong>Design for testability</strong> resurfaces the problems we often face while unit testing <em>badly</em> designed classes. The mitigation approach is to have white-boxed tested classes, which could be enough but is not the best approach for testing. Again the solution to this appeared to be in thinking of separating concerns at the early development stage.</p> <p>In the next section, the author takes us into the <strong>Art of building abstraction</strong> to effectively place the requirements and expectations into the code. In OOP-based languages, abstractions are usually built using base classes and also can be built using concepts (or equivalent). Many times these introduce more problems where we can use abstractions using free functions. This aspect is touched on in many ways later to show how we can achieve decoupling and separate concerns. Nevertheless, in all these forms of abstraction building it is important to adhere to LSP to forward the expectations correctly and DIP to think in terms of ownership of the introduced abstractions. Next the author talks about what purpose the design patterns serve - to provide a blueprint for the organizational software to be built upon. Naming design patterns with commonly known patterns helps to pass on intent and information to developers. The author again emphasizes that design patterns are not only limited to OOP or dynamic polymorphism, they can be very well extended to functional or generic programming.</p> <p>The open-for-extension guideline in OCP can be interpreted in two ways: open for extending types or open for extending operations. Procedural programming gives us ease of adding new code for extending the operations but gets tougher to add new polymorphic types. On the other hand with OOP, we get the ease of adding new polymorphic types but it is tougher or impossible for adding new operations without recompiling the base classes. In the early stage of the project, one must make a conscious decision about which path of extension he/she wants to follow. It is important to understand that no design fits all-purpose and has its advantages and disadvantages.</p> <h1 id="23-strategy-pattern-observer-and-crtp">[2/3] Strategy pattern, Observer and CRTP</h1> <p>Slowly the the design topics starts getting a bit complex.</p> <p>From the second tierce of the book, we start to get into various design patterns of both structural and behavioral patterns. First, we cover the visitor pattern and embrace it to solve our problems with the extension of operation in the inheritance hierarchy using double dispatch. Although naturally with this approach it gets tougher to add new types. We also learn that since we have double indirections used this design becomes quite inefficient by design. Next author introduces the std::variant style of visitor pattern, with which creating abstraction becomes quite easy. With std::variant we can group any unrelated types and based on the the type present at the call we can perform operations accordingly with the help of std::visit(). The new operations logic can be added on top without going back and changing any of these classes. While looking at the benchmarked result, it is worth mentioning that there are further nuances of these of writing your own get_if() functions to call particular operations based on the type provided. Refer the book to see various interesting benchmarks reported by the author.</p> <p>Then we move to cover the strategy pattern and command pattern. The strategy pattern intends to extend the polymorphic types of a class without much fuss. Strategy class can be thought of as serving complimentary aspect of open for extension as of visitor and also can be thought of as extracting the complex algorithms into separate entities being it a class or free function. Strategy entity can be injected as a dependency into the subject class. One of the downside in this pattern (also to be able to follow SRP) is that for each operation we need to add one strategy. One can use a <strong>Policy-based strategy design pattern</strong> by passing a policy in the form of a function object or lambda. We investigate the command design pattern next, which looks very similar and has the same implementation as that of the strategy design pattern. The only difference comes from the architectural point of view. For that matter even from the type of structural pattern, the adaptor design patterns strike as similar to strategy but the intent it serves is different. It becomes easy to think about the design when you think from the perspective of what intent they serve. We also cover differences in reference semantics (used often by OOP-based) and value-based designs. In this case, our policy-based designs emphasize the point of value-based semantics.</p> <p>Next, we go through the Adaptor pattern, the Observer pattern, and the CRTP pattern. Adaptor patterns are used to standardize the interfaces or to introduce a shim layer between the client and implementation details. Adaptors can be formed through creating an intermediate class or even by functions. Observer pattern is used where we require a notification system for a state change of the data, we are interested in. It creates a one-to-many relation between the subject (data we are interested in) and the observers. It is good to be aware of the further niche of this design: push observer and pull observer. It is also important to highlight that the observer pattern can be attained via value semantics as well. The CRTP pattern creates a compile-time abstraction for a family of related types. This is attained by using templates of the derived type, where we static cast this pointer to the derived class and access the methods we want to call. Note here since we use a template for the base class, we do not have the same base class for all derived types. C++20 concepts help us to implement this pattern.</p> <h1 id="33-bridge-prototype-and-type-erasure-pattern">[3/3] Bridge, prototype and type erasure pattern</h1> <p>The final third part of the book contains few of the most complex design patterns. If I were to go back referring to this book it would be mostly for this part of the book. The bridge pattern (belongs to the structural pattern domain ) can be used to isolate different concerns and bridge them. We can remove direct physical dependency between modules so that either end can evolve without affecting others (like retriggering recompilation etc.). The Pimpl Idiom is a more famous part of the bridge pattern. We can achieve ABI stability with this pattern. If we introduce more abstraction layers (and more indirections) it may appear that the efficiency could take a toll, which is true in most of the cases, but refer to the book to see where it can be even better than the unaltered design.</p> <p>The prototype pattern is used to self-clone concrete types from its base class object pointer. It is equivalent to having a virtual copy constructor. External polymorphism is a non-intrusive method to lets the user use the non-related (no-inheritance) classes to be treated polymorphically. There are new terms like concepts class (base) and model classes (derived from concept class) used. The important thing to know is that for different types of classes, there are different base classes (which could be templatized). This pattern takes advantage of it being non-polymorphic (fewer indirections), can be easily extendable according to OCP, and follows DRY and DIP. However, this pattern does not follow value semantics.</p> <p>The intent of the type erasure design pattern is to provide value-based non-intrusive abstraction for unrelated types but with the same semantic behavior. The type erasure design pattern contains a combination of external polymorphism, bridge pattern, and potentially prototype design pattern. It got its name because of the fact that the abstract class does not store the information about the concrete type of the object hence the type is erased. The author also adds optimization techniques like using SBO instead of dynamic memory to allocate and deallocate memory or manual dispatch instead of virtual table indirections.</p> <p>Decorator pattern allows dynamically attaching new functionality to the existing types without changing the types. In other words, it is a flexible alternative to subclassing for extending functionality. The author tells the reference from the GoF book about how the analogy of strategy being the gut of the object and decorator being the skin. The author also gave a quick tour of the Singleton pattern. Singleton pattern is infamous for the issues with SIOF, hindrance to testability, etc. The author shows us how strategy patterns could be used to invert dependency of the singleton pattern easily for testability.</p> <p>I hope you enjoyed reading this summarisation and find it helpful. If you decide to read the book do enjoy it! If you have already read the book, let me know if you have something more to add.</p> <h1 id="abbreviations">Abbreviations:</h1> <ul> <li>OOP: Object Oriented Programming</li> <li>DRY: Do Not Repeat yourself</li> <li>SOLID: 5 most famous software programming principle next in line -</li> <li>SRP: Sinogle Responsibility Principle</li> <li>OCP : Open Close Principle</li> <li>LSP: Liskov’s Substitution Principle</li> <li>ISP: Interface Segregation Principle</li> <li>DIP: Dependency Inversion Principle</li> <li>CRTP: Curiously Recurring Template Pattern</li> <li>SBO: Small buffer optimization</li> <li>SIOF: Static initialization order fiasco</li> <li>GoF: Gang of four book - Design Patterns: Elements of Reusable Object-oriented software</li> </ul>]]></content><author><name></name></author><category term="Design"/><category term="books"/><category term="Design,"/><category term="Book-reviews,"/><category term="C++"/><summary type="html"><![CDATA[Book-review for C++ Design pattern – Klaus Iglberger]]></summary></entry></feed>