<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.4">Jekyll</generator><link href="https://piyja.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://piyja.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2024-11-17T17:36:18+00:00</updated><id>https://piyja.github.io/feed.xml</id><title type="html">blank</title><entry><title type="html">Book Review Building Secure Cars</title><link href="https://piyja.github.io/blog/2024/Book-review-Building-Secure-Cars/" rel="alternate" type="text/html" title="Book Review Building Secure Cars"/><published>2024-05-05T00:00:00+00:00</published><updated>2024-05-05T00:00:00+00:00</updated><id>https://piyja.github.io/blog/2024/Book-review-Building-Secure-Cars</id><content type="html" xml:base="https://piyja.github.io/blog/2024/Book-review-Building-Secure-Cars/"><![CDATA[<h2 id="how-i-got-around-the-book">How I got around the book</h2> <p>On the quest of learning the horizontals topics in automotive software, I found myself willing to know more about the security features and measures used in automotive software development. As developer within the infotainment business of the automotive I find security as growing requirement as the capabilities of it are ever-growing. Infotainment Electronic Control Units (ECUs) have emerged as potent components within vehicles, often handling critical functionalities. My expectation from the book was to gain insights into how security is intricately woven into the software development lifecycle. I anticipated learning about various security features implemented in automotive systems, as well as the diverse types of security testing conducted. This knowledge would not only enrich my understanding of current practices but also equip me with the necessary tools to navigate and contribute effectively within the humungous landscape of automotive software development.</p> <h2 id="what-did-i-learn-from-the-book">What did I learn from the book</h2> <p>The author effectively underscores the critical importance of security and adeptly caters to newcomers by providing detailed explanations. While seasoned professionals may find some concepts verbose, this approach ultimately deepens understanding. Key concepts that stood out and are worthy of highlighting are mentioned in the below part of the blog:</p> <h3 id="importance-of-security-in-automotive">Importance of security in automotive</h3> <p>Given the rapid evolution and increasing complexity of modern vehicles following are points which state why software security is crucial:</p> <ol> <li>Growing Capabilities and Dependency on Software: Modern vehicles are becoming increasingly sophisticated, relying heavily on software to manage everything from basic functions to advanced features like autonomous driving. This growing dependency means that the integrity and security of the software are paramount.</li> <li>Increased Code Complexity and Potential Vulnerabilities: As the amount of code within a vehicle’s systems increases, so does the potential for vulnerabilities. More lines of code create more opportunities for bugs and security flaws, making robust security measures essential.</li> <li>Elevated Risk Factors: With the introduction of more capabilities, the risk associated with potential vulnerabilities also rises. Security breaches can have severe consequences, affecting not only the vehicle’s functionality but also the safety of passengers and pedestrians.</li> <li>Necessity for Updated Security Features and Testing: The dynamic nature of automotive technology demands the most current security features to protect against emerging threats. Regular and thorough security testing is crucial to identify and address vulnerabilities early in the development process, ensuring that vehicles remain secure against potential attacks.</li> </ol> <h3 id="how-can-we-make-automotive-more-secure---static-approaches">How can we make automotive more secure - Static approaches</h3> <h4 id="secure-hardware-solutions">Secure hardware solutions</h4> <p>Hardware solutions play a crucial role in enhancing the security of automotive software by enabling privileged access to applications and ensuring the integrity of the system. Key hardware-based security features include secure boot, secure flash, secure log, and secure debug. These mechanisms ensure that only authorized software can run on the vehicle’s systems, protecting against unauthorized access and tampering.</p> <p>Additionally, trust-based systems can be implemented to physically isolate sensitive data and manage secure connections. This can be achieved through secure trust zones, which create a dedicated and protected environment within the hardware. These secure zones store sensitive information and control access using robust security protocols, thereby enhancing the overall security posture of the automotive system. By leveraging these hardware security measures, automotive manufacturers can provide a more secure and resilient platform for their vehicles, safeguarding against a wide range of potential threats.</p> <h4 id="software-composition-analysis-of-open-source-components">Software composition analysis of open source components</h4> <p>Software composition analysis involves understanding the various components that make up an application and the dependencies it relies on. By thoroughly analyzing the composition of your software, you can identify all the open-source components integrated into your application. It helps in recognizing known vulnerabilities and flaws associated with these open-source components. Many open-source libraries and modules have publicly documented security issues, and being aware of these can prevent the introduction of potential security risks into your software. It enables proactive management of software updates and patches, ensuring that any vulnerabilities discovered in the open-source components are promptly addressed. It also supports compliance with industry standards and regulations, thereby contributing to the creation of a secure and reliable automotive software environment.</p> <h4 id="static-code-analysis-sca">Static code analysis (SCA)</h4> <p>Static code analysis (or linters) are means of checking software code for abiding to the coding standards by parsing the source code. These checks are run without executing the code on the software code base. The checks are not just on a particular statement or definition but can also detect issues in a block of related source code. It can find both syntactic and semantic code violations within the code base. Specific to automotive industry some consortiums have developed coding standards to be followed in automotive software, like <a href="https://misra.org.uk/">MISRA</a> and <a href="https://www.autosar.org/fileadmin/standards/R22-11/AP/AUTOSAR_RS_CPP14Guidelines.pdf">AUTOSAR</a>. There are many open sources projects which offers many of these standards included in the SCA tooling software. As well there few proprietary software like, <a href="">Coverity</a> covers about the majority of the coding standards into their linter and has about 400 coding guidelines which it covers. These standards are split in categories of severeness - mandatory, required and advised. For safety related code within automotive there are stricter guidelines which are covered in ASIL-D &lt;(ISO, SIL B-C??)&gt; coding standards. Not all software component would need to abide by all coding standards and can be configured according to the functional severity. Albeit, one thing is worth mentioning some violations could be false positive and there are provisions to bypass this and allow deviations case by case, although this requires human code review.</p> <p>For the legacy code where we would get unmanageable amount of code violations at first, one has to set up a framework to be able to introduce this gradually into the full working. This could mean segregation of the software components based on the functional severity and enabling the coding guidelines as per this severity. Then case by case going through the violations to identify which ones should be resolved at a priority hierarchy.</p> <h3 id="how-can-we-make-automotive-more-secure">How can we make automotive more secure</h3> <h4 id="by-shifting-left">By Shifting left</h4> <p>By introducing security testing approaches in the (software development V cycle)[] we can bring more robustness into the software. These testing can be performed in the cycle to expose vulnerability earlier and to avoid making security being an afterthought at the verifications step.</p> <h4 id="theoretical-approach">Theoretical Approach</h4> <p>Theoretical approaches like Threat Analysis and Risk Assessment (TARA) can prove to be a beneficial starting step to analyze the software. It involves identifying the assets and threat scenarios and creating risk assessment of the identifies threats. It proves to be greatly beneficial if carried out multiple times in the development cycle. The final output of this analysis is list of identifies threats and associated risks with it which can be sorted by their priorities. There are good open source tools like (pyTM)[https://github.com/izar/pytm] which can be used create a graphical output of the analysis using graphviz. Albeit, TARA would also be classified as a static approach in identifying threats.</p> <p>To make automotive more secure, more than static approaches are essential, by dynamic I mean in which we emulate close to actual use case of the automotive systems. From testing point of view this involves controlling the external environment for the system under test (SUT) and monitoring its behavior. In the following section we will see more about them.</p> <h4 id="practical-testing-approaches">Practical testing approaches</h4> <p>Practical testing approaches can be divided into following sections:</p> <h5 id="functional-security-testing">Functional security testing</h5> <p>Akin to system function testing, the focus is on validating the effectiveness of essential security functionalities. This encompasses rigorous testing of critical security features integrated into the communication stack, such as SecOC (Secure Onboard Communication), and evaluating standard encryption mechanisms applied to cryptographic algorithms for handling sensitive data. Additionally, assessing the reliability and performance of components like the true random generator is vital.</p> <h5 id="vulnerability-testing">Vulnerability testing</h5> <p>In vulnerability testing, the initial phase involves comprehensive information gathering focused on understanding the system’s core components. This process employs various scanning techniques from multiple perspectives to thoroughly examine the software. Communication ports are scanned to identify potential vulnerabilities, while configurations used within the software are meticulously scrutinized. Additionally, critical details such as the communication protocols utilized by the target system are analyzed to gain deeper insights into its operational structure. Once these key components are identified, the next step involves gathering and analyzing potential threats. This proactive approach ensures that developers can anticipate security risks early in the development process, thereby integrating robust defensive measures into the automotive software.</p> <h5 id="fuzz-testing">Fuzz testing</h5> <p>Fuzz testing is a method used to evaluate the behavior and robustness of an application by providing randomly generated data as input and observing how the system responds. It is highly adaptable, with no single fixed approach and also incorporate model-based input generation, which systematically produces random data inputs to enhance the testing process. This technique is instrumental in identifying vulnerabilities and weaknesses within the software.</p> <p>A typical fuzz testing setup involves three main components:</p> <ul> <li>Engine: Responsible for generating randomized inputs.</li> <li>Injector: Introduces these inputs into the application under test.</li> <li>Monitor: Observes and checks the application’s behavior for any anomalies or crashes.</li> </ul> <p>There are three main types of fuzz testing:</p> <ul> <li>Black Box Testing: Testers have no knowledge of the internal workings of the application. Inputs are generated and injected without any insight into the system’s internals.</li> <li>Grey Box Testing: Involves partial knowledge of the system, allowing testers to create more informed and targeted inputs while still retaining some randomness.</li> <li>White Box Testing: Testers have full knowledge of the system, enabling them to create highly specific and strategic inputs to probe for vulnerabilities. The author covers fuzz testing in great detail across many chapters of the book. This comprehensive exploration provides a deeper understanding of how fuzz testing can be effectively employed to enhance the security and reliability of automotive software. We will cover key information here in the blog but for more detailed explanations and advanced topics on fuzz testing, refer to the later sections of the book.</li> </ul> <h6 id="testing-classical-autosar-components">Testing classical AUTOSAR components</h6> <p>“Shifting-left” approach in the software development <a href="https://en.wikipedia.org/wiki/V-model_(software_development)">V model</a> pushes us to integrate testing earlier in the development process to identify and resolve issues sooner. Owning to the vast security knowledge coming from IT industry, testing automotive specific CAN protocol based Classic AUTOSAR components can be particularly challenging, necessitating the use of Hardware-in-the-Loop (HIL) testing to ensure thorough and accurate validation. HIL testing involves two primary types of result monitoring:</p> <ul> <li>White Box Testing: This approach involves monitoring the internal states of the System Under Test (SUT). It provides detailed insights into the internal workings and allows for the identification of specific issues within the system’s components.</li> <li>Black Box Testing: In this method, the overall behavior of the system is monitored without focusing on its internal states. Usually in the case system’s performance is compared against an identical reference behavior to ensure it operates as expected.</li> </ul> <p>The integration of HIL in fuzz testing offers significant benefits, particularly in terms of quality of the feedback. By simulating real-world conditions we can get the closer to real life feedback from the hardware interactions, which helps in identifying and catching exceptions that might not be evident through software-only testing. This approach leads to the development of more robust and reliable automotive software, ensuring the system meets the stringent requirements of modern automotive applications.</p> <h6 id="testing-services-within-operating-systems-os">Testing Services Within Operating Systems (OS)</h6> <p>As automotive software becomes increasingly complex with the integration of custom OS, it is essential to adapt our testing strategies accordingly. One effective approach is white box fuzz testing, which employs agents to monitor and capture detailed information about various processes composed in the automotive OS. These agents track critical OS details such as memory corruptions (e.g., use-after-free errors), heap and stack checks, initialization order problems, memory leaks, core dumps, process monitoring, system logs etc.</p> <p>External agents play a significant role in monitoring the communication layer, including protocols like Bluetooth, WiFi, MQTT, and file formats. This comprehensive monitoring helps in identifying vulnerabilities and ensuring the robustness of the automotive software.</p> <p>There are two primary types of monitoring methodologies:</p> <ul> <li>Asynchronous Monitoring: random inputs are provided without waiting for corresponding results. The advantage of asynchronous monitoring is the speed at which results are delivered. However, the downside is that there are fewer options for tracking and tracing the outcomes, which can make it harder to diagnose issues.</li> <li>Synchronous Monitoring: This method involves waiting for the results of each input action before proceeding to the next which cause delays. The main advantage of synchronous monitoring is that it allows for easy tracking and tracing of results, making it simpler to identify and resolve issues.</li> </ul> <h5 id="penetration-testing">Penetration testing</h5> <p>Penetration testing is a crucial security evaluation performed in the final stages of product development. Its primary objective is to identify and exploit potential vulnerabilities within the system to understand how it might fail under various attack scenarios. This type of testing requires detailed understanding of the system to create situations that could lead to application failures.</p> <ul> <li> <p>Black Box Testing: In this approach, the tester has an understanding of the system behavior but no insider knowledge of its internal workings. The tester uses this information to attempt to exploit the system, identifying vulnerabilities that an external attacker might find.</p> </li> <li> <p>White Box Testing: This method involves the tester having comprehensive insider knowledge of the system. While it can be debated how realistic such attack scenarios might be, this approach is invaluable for understanding the risks associated with internal threats. By leveraging detailed system information, testers can perform more targeted and thorough security assessments.</p> </li> </ul> <p>Penetration testing provides a holistic view of the system’s security posture, helping developers identify and mitigate potential risks before the product is released. This ensures that the releases are more robust and resilient against potential attacks.</p> <h4 id="robust-frameworks-are-required">Robust frameworks are required</h4> <p>While various tests are crucial for proving the robustness of a system, merely having test suites is insufficient. To ensure comprehensive security testing throughout the product development and maintenance lifecycle, a robust framework is essential. Such a framework provides a systematic approach to security testing, ensuring that all aspects of the system are thoroughly evaluated, and any potential vulnerabilities are addressed promptly. A robust framework must contain following steps: Analyse the problems, set the goals, Identify the current state, define strategy to archive goals and execution.</p> <h3 id="continuous-monitoring">Continuous monitoring</h3> <p>Performing security tests once is not sufficient to ensure the ongoing robustness and security of automotive software systems. Continuous monitoring is essential to maintain a high level of security and quickly identify and address new vulnerabilities as they arise. Such a system continuously monitors the application and its environment for potential security threats and anomalies. This approach ensures that any new vulnerabilities or changes in the system’s behavior are detected promptly, allowing for immediate corrective actions.</p> <p>Hope you enjoyed reading the blog and learned new concepts about security testing. If this blog intrigued I would recommend diving further into the book.</p>]]></content><author><name></name></author><category term="Design"/><category term="books"/><category term="Automotive,"/><category term="Security"/><summary type="html"><![CDATA[Book review - Building secure cars - Assuring the Automotive Software Development Lifecycle - by Dennis Kengo Oka]]></summary></entry><entry><title type="html">Why Automotive Software Is Moving Towards Adaptive Autosar</title><link href="https://piyja.github.io/blog/2024/Why-Automotive-Software-is-moving-towards-Adaptive-Autosar/" rel="alternate" type="text/html" title="Why Automotive Software Is Moving Towards Adaptive Autosar"/><published>2024-03-27T00:20:00+00:00</published><updated>2024-03-27T00:20:00+00:00</updated><id>https://piyja.github.io/blog/2024/Why-Automotive-Software-is-moving-towards-Adaptive-Autosar</id><content type="html" xml:base="https://piyja.github.io/blog/2024/Why-Automotive-Software-is-moving-towards-Adaptive-Autosar/"><![CDATA[<p>In the last few days, I dedicated some time to learning about the Adaptive AUTOSAR (AA) platform. Anticipating the course of automotive software development, it becomes important to understand the problems that AA aims to solve. In the past, our team worked closely with AA to develop a consumer service application that provided some sensitive data, but the inner workings of the platform were still to be explored. The challenge in understanding AA was in the multilevel workflow from modeling the system and deployments to finally developing the applications. Wrapping one’s head around the complete process is a time-consuming task. In a functional automotive project, there are teams working on each level of this development work, which together execute the complete process. In the following sections, I have jotted down important points to gain a high-level understanding of AA.</p> <p>Before delving more into AA, let’s understand more about AUTOSAR and its developments before AA.</p> <h2 id="what-is-the-autosar-consortium">What is the AUTOSAR Consortium?</h2> <p>The <a href="https://www.autosar.org/">AUTOSAR Consortium</a> is a joint effort from leading automotive industry companies to create and define open system architecture standards for automotive. This includes not only providing a standardized software architecture and framework, but also the base standards for E/E architecture. It’s fascinating to see how competitive automobile companies have come together to create unified standards and pave the road for future developments.</p> <h3 id="so-what-software-standards-are-they">So, what software standards are they?</h3> <ul> <li><em>Foundation standards</em> - created to ensure a high degree of interoperability between components of AUTOSAR platforms, i.e., Adaptive and Classic, as well as within AUTOSAR to non-AUTOSAR platforms.</li> <li><em>Platform standards</em> - like Classic and Adaptive AUTOSAR standards. More on this in the following sections of the article.</li> <li><em>Application interfaces</em> - introduced various standardization processes for the communication protocols, syntax, and semantics for all applications to communicate in commonly understood terms.</li> <li><em>Acceptance test packages</em> - various standards are set for system tests to ensure the developed applications comply with the set standards.</li> </ul> <h3 id="more-about-classic-autosar">More about Classic AUTOSAR</h3> <p>The main purpose of Classic AUTOSAR is to achieve hardware and platform independence for AUTOSAR applications. The underlying layers of software are more dedicated to the type of hardware and platform. AUTOSAR provides a runtime environment (RTE), which is a software abstraction layer that the application software uses to work with hardware-oriented basic software (BSW). AUTOSAR also provides standardization guidelines for this BSW layer. Along with this, it has introduced common methodologies for configuring the AUTOSAR stacks.</p> <p>Classic AUTOSAR provides the base format for integrating a new ECU into the vehicle network. It mainly addresses the signal-based approach of communication, i.e., <a href="https://en.wikipedia.org/wiki/CAN_bus">CAN bus</a>, <a href="https://en.wikipedia.org/wiki/Local_Interconnect_Network">LIN bus</a>, etc. With this approach, endpoints can be easily configured with config files without changing the application software. However, for an update in the software component, an update of the entire ECU firmware is essential, which is a major drawback. Another disadvantage is that adding a new ECU usually requires a major change in the schema.</p> <p>However, in the following sections, we will see how Adaptive AUTOSAR overcomes these challenges and at what cost.</p> <h2 id="understanding-adaptive-autosar">Understanding Adaptive AUTOSAR</h2> <h3 id="why-are-automotive-software-components-moving-towards-adaptive-autosar">Why are automotive software components moving towards Adaptive AUTOSAR?</h3> <p>As more compute-demanding features like ADAS and V2X are being integrated, the number of ECUs and the computational capacity of the ECUs in automotive have been continually growing. This poses a challenge for designing the communication between these endpoints. Adaptive AUTOSAR (AA) proposes to integrate domain-specific high-performance ECUs in the vehicle to serve as a gateway for communication into each domain. Smaller footprint embedded ECUs directly connect to their respective domain’s high-performance ECU in order to communicate with the entire vehicle network. Another advantage of an AA application is that it can be configured and integrated into the system at runtime. This allows a number of independent services to be developed, tested, and deployed as applications independently.</p> <h3 id="embracing-the-change-in-the-way-of-communication-between-the-software-components">Embracing the change in the <strong>way of communication</strong> between the software components</h3> <p>As we have seen, there is increased usage of gateway ECUs to enhance the efficiency of the vehicle network. These domain ECUs manage the communication with smaller ECUs using a signal-based protocol and communicate with other domain ECUs using IP-based protocols to form a <a href="https://www.vector.com/int/en/know-how/autosar/autosar-adaptive/#c122761">domain controller architecture</a>. This allows more sophisticated frameworks like <a href="https://en.wikipedia.org/wiki/Service-oriented_communications">service-oriented communication</a> to be possible in automotive software. These services can be either servers (data providers or provider ports) or clients (data consumers or required ports) and communicate in the following ways for any data transfer:</p> <ul> <li>Direct method calls</li> <li>Event-based communication</li> <li>Topic or Data field subscription</li> </ul> <p>The system design manifest files define how these servers and clients are laid out in the E/E architecture. An application developer can use both <a href="https://en.wikipedia.org/wiki/Inter-process_communication">IPC</a> or <a href="https://en.wikipedia.org/wiki/Remote_procedure_call">RPC</a> method calls to a known service in the same manner without knowing the underlying modes of communication. AA also uses what is commonly known as the <a href="https://en.wikipedia.org/wiki/Service_discovery">“Service Discovery”</a> mechanism to keep track of up and running services offered on the vehicle network.</p> <h3 id="adaptive-autosar-architecture">Adaptive AUTOSAR Architecture</h3> <p>The Adaptive AUTOSAR (AA) software middleware stack can be thought of as a broader and wider design than Classic AUTOSAR, also known as AUTOSAR Runtime for Adaptive Applications (ARA). The modules within the ARA can be accessed through the <code class="language-plaintext highlighter-rouge">ara::</code> namespace within C++ applications and are platform-agnostic. The AA application uses ARA modules and sits at the top of the software architecture block designs, while the hardware drivers, hypervisors, and container modules sit at the bottom of the ARA components. The following is a non-exhaustive list of modules that ARA offers:</p> <ul> <li>Core platform services <ul> <li>Network</li> <li>State management, etc.</li> </ul> </li> <li>Platform foundation <ul> <li>Communications stack</li> <li>Persistency</li> <li>Logging and trace</li> <li>Platform health, etc.</li> <li>Includes all PSE51 POSIX APIs provided by the OS</li> </ul> </li> </ul> <h3 id="process-workflow-and-modelling-for-aa-applications">Process Workflow and Modelling for AA Applications</h3> <p>The process workflow for developing AA applications consists of modelling, auto-generating source code, and then developing the application software. The modelling steps involve filling in the details of the manifest files, which are then used to develop the auto-generated source code. Manifest files are divided into the following three parts:</p> <ul> <li>System design</li> <li>Machine and execution level</li> <li>Deployment level</li> </ul> <h3 id="so-what-is-adaptive-about-adaptive-autosar">So, what is <strong>adaptive</strong> about Adaptive AUTOSAR?</h3> <p>While learning about AA topics, many of us have queries centered around this question. I will attempt to explain this in my own words.</p> <p>Adaptive AUTOSAR (AA) provides a platform for applications to become platform-agnostic. This means that the applications developed are not constrained to a particular platform or hardware type, as it separates configurations from the application software. It uses manifest files in the form of JSON extensions, which are configured alongside the application being developed. The final binary flashed onto the ECUs contains the application binaries and deployment configuration manifest files. These manifest files also define the service and client endpoint definitions, allowing for dynamic runtime linking between them for communication.</p> <p>As we also saw earlier in this article how independent features can be divided into AA applications or services. These applications can be also tested and deployed into the ECUs making it a very easy process to roll out any AA updates into the vehicle as opposed to completely re-flashing the ECU software. This adds a lot of agility into the AA applications.</p> <h3 id="do-you-have-safety-critical-or-hard-real-time-requirements-for-your-applications">Do you have safety-critical or hard real-time requirements for your applications?</h3> <p>As AA applications run on the ARA platform, which is capable of keeping the soft real-time requirements, it is not completely reliable for the hard real-time requirements. For example, engine control and brake systems. If the application’s requirement is to provide safety-critical features such as air-bag ECUs, it is recommended to use classic AUTOSAR applications. However, for safety features which are not specified as hard-real time, AA applications can achieve up to ASIL-B (these days also ASIL-D) using the safety libraries provided by different vendors. As Classic AUTOSAR application does not need an OS to run, its bootup time is also quite less compared to AA applications.</p> <h2 id="technical-criticisms-on-autosar">Technical criticisms on AUTOSAR</h2> <p>Every design decision has a trade-off associated with it. AUTOSAR standards have used an approach of “one solution fits all”, making it form a heavy footprint software stack. This causes application sizes to bloat up. In very resource-constrained embedded environments, this application may not be the right choice and more targeted applications could do a better job. There are many <a href="https://medium.com/volvo-cars-engineering/the-reality-of-autosar-and-the-way-forward-36af39ec4099#:~:text=One%20of%20the%20biggest%20problems,of%20OEM%2Dspecific%20software%20applications">criticisms</a> on AUTOSAR and a lot of development entities are looking for alternative approaches.</p> <h2 id="further-words">Further Words</h2> <p>For full disclosure, I have been learning about AA from detailed training courses from <a href="https://www.vector.com/int/en/">Vector</a> in the last few days, where we delved into the implementation details of Vector’s AUTOSAR products.</p> <p>I hope you now have a high-level understanding of AUTOSAR, what AA is, its motivation for existence, and how AA applications are used in automotive.</p>]]></content><author><name></name></author><category term="Automotive"/><summary type="html"><![CDATA[What is adaptive about Adaptive AUTOSAR?]]></summary></entry><entry><title type="html">Book Review Fundamentals Of Software Architecture</title><link href="https://piyja.github.io/blog/2024/Book-review-Fundamentals-of-Software-Architecture/" rel="alternate" type="text/html" title="Book Review Fundamentals Of Software Architecture"/><published>2024-03-09T00:20:00+00:00</published><updated>2024-03-09T00:20:00+00:00</updated><id>https://piyja.github.io/blog/2024/Book-review-Fundamentals-of-Software-Architecture</id><content type="html" xml:base="https://piyja.github.io/blog/2024/Book-review-Fundamentals-of-Software-Architecture/"><![CDATA[<h1 id="why-did-i-pick-this-book">Why did I pick this book?</h1> <p>Coming from a product design background and writing software in embedded products, curiosity drives me to go beyond software design and development layers. Just like any hardware-based product, software products are an amalgamation of different software principles. This natural curve opened an opportunity for me to take on architectural tasks within the scope of my development activities. Offlate I have been getting involved at the system level components and piecing out the different information points into the system architecture. To take this further into streamlined learning, it is impossible not to stumble upon the famous book - <a href="https://fundamentalsofsoftwarearchitecture.com/">Fundamentals of Software Architecture by Mark Richards and Neal Ford</a>.</p> <p>In the following part of this article, I have tried to give you a brief introduction to the book and give you my personal learnings from it. This article is purely for academic purposes and is part of my contribution to the software community world. If this interests you, I would highly recommend reading the book further.</p> <h1 id="structure-of-the-book">Structure of the book</h1> <p>This book is written in three independent sections to cover the holistic view of software architecture.<br/> <em>Part I</em>: Covers the foundation of the software architecture, defining it and breaking it down into its core blocks. It also covers means of identifying, measuring, and governing architectural characteristics.<br/> <em>Part II</em>: Here it covers different architectural designs and assessment of the characteristics of it in star rating format.<br/> <em>Part III</em>: Then it talks techniques and the soft skills to be an effective architect. Author talks about recording architectural decisions - on useful methods and tools to do it.</p> <p>Following are the key highlights I have noted and written in my words.</p> <h1 id="what-software-architecture-is-about">What software architecture is about?</h1> <h2 id="defining-the-architecture">Defining the architecture</h2> <p>On the same lines of Martin Fowler’s definition in his famous article <a href="https://martinfowler.com/ieeeSoftware/whoNeedsArchitect.pdf">“Who needs an architect”</a> quoted “Software Architecture is about the important stuff, whatever that is”, the authors re-enforces this and has made an excellent attempt to explains us to why that is true. In the age of the programming world, software architecture has a constantly evolving role and hence its definition. In the most general terms, it can be equivalent to understanding the system which is divided into its components and connected with interfaces. As the authors quoted</p> <blockquote> <p>It is the highest level concept of the expert developers and their shared understanding The focus of software architecture should be more on the <code class="language-plaintext highlighter-rouge">WHY</code> than the <code class="language-plaintext highlighter-rouge">HOW</code> part.</p> </blockquote> <h2 id="software-architectures-4-sides">Software architecture’s 4 sides</h2> <p>The designing process of an effective piece of software can be further split into following steps:</p> <ul> <li>Structure - The base technology stack which forms the structural part of your software</li> <li>Characteristics - The technological properties which want your software to bring across</li> <li>Decisions - The decision tree which led to final software product</li> <li>Design principles - The principles which were closely followed while development</li> </ul> <p>The authors have provided easy to understand pictorial depictions for the above point which is helpfully embossing.</p> <h3 id="architectural-thinking---broadening-the-breadth">Architectural thinking - broadening the breadth</h3> <p>A developer’s mindset is to dig deeper into few chosen / relevant topics, while an architect needs to have an overview on a range of different technologies. Surely an architect needs to know a few topics well in depth but the part where they start making the difference is having an overview of the technologies used in the product.</p> <h4 id="defining-architectural-characteristics">Defining architectural characteristics</h4> <p>There are two types of architecture characteristics - explicit and implicit. Explicit characteristics are the ones which directly surface based on the solution provided and are non-domain specific design considerations. On the other hand implicit characteristics are the ones which are influenced from the structural aspects of the designs and are generally related to the domain specific knowledge. Let us take an example of designing a website for an online ticket booking system - here the characteristics such as reliability, availability, performance, scalability, etc. are explicitly covered while aspects such extensibility, upgradability, privacy, security etc. could be classified as implicit. I agree it is not 100% clear on how to label the characteristics, but the important point is to think from the perspective of the difference in domains and non-domain related characteristics.</p> <h4 id="identifying-architectural-characteristics-in-a-given-use-case">Identifying architectural characteristics in a given use case</h4> <p>One of the initial steps while architecting is to identify the characteristics. They can be extracted from the domain knowledge and the requirement documents. There is no specific set of rules to follow while identifying them, but one can practice through architectural Kata exercises. Please refer below what architectural Katas are.</p> <h4 id="measuring-and-governing-these-characteristics"><strong>Measuring</strong> and <strong>Governing</strong> these characteristics</h4> <p>Authors show us the importance of measuring the measurable characteristics as a means of justifying your decisions. Authors introduced techniques to measure characteristics of modularity via cohesion, coupling and connascence properties. This would help quantify the characteristics which sets a good platform for comparing decisions. For effective decision-making it is important to analyse the detailed output and form fitness functions. From these reports an architect gets the opportunity to govern the decision-making process.</p> <h4 id="component-based-thinking---conways-law">Component based thinking - Conways Law</h4> <p>Conways Law suggests that the organisation’s communication structure heavily influences the design structure of the product it is developing. The flow of information in an organisation is affected by how the teams are structured which then affects the decision-making process. Based on the decision the ownership of the different building blocks aka components are influenced and hence the overall design structure gets altered. As Martin Fowler mentioned there are three ways to deal with this law:</p> <ol> <li>Ignore - it is proven to be ineffective to fight against it</li> <li>Accept - make sure your architecture incorporates the designers communications pattern</li> <li>Inverse Conway Maneuver - make changes in the communication patterns to achieve design architecture</li> </ol> <p>The identification of the software components of a product can be done either based on technical or domain related. It is important to understand both divisions inorder to make knowledgeable trade off decision.</p> <h3 id="brief-introductions-into-the-architectural-patterns">Brief introductions into the architectural patterns</h3> <p>The author covered detailed definitions, descriptions and purpose of the various architectural designs. The designs covered are the following -</p> <ul> <li>Big ball of mud</li> <li>Monolithic architecture</li> <li>Component based design</li> <li>Service oriented architecture</li> <li>Service defined architecture</li> <li>Microservices</li> <li>Space based architecture</li> </ul> <p>I will not go further into the design patterns in this article as it will not do the justice to all of them in a short article. But if you are interested to know further I encourage reading up further in the book and other online resources. The interesting part in this book is about the comparison which was made on all the designs. The following mentioned architectural characteristics are used as the comparison - Deployability, Elasticity, Evolutionary, Fault tolerance, Modularity, Cost, Performance, Reliability, Scalability, Simplicity and Testability.</p> <h2 id="techniques-for-practicing-architecture">Techniques for practicing architecture</h2> <h4 id="practicing-with-architectural-katas">Practicing with Architectural Katas</h4> <p>To become a good architect one needs to practice making architects designs. In the beginning of my journey into this I struggled to find platforms to exercise architecture and the decision-making process. This book introduces the concept of architectural katas, a concept originally formed by <a href="https://www.architecturalkatas.com/">Ted Neward</a>. It is an exercise where a bunch of enthusiasts come together to design a different system and a moderator who not only assigns the tasks but also keeps track of the time. <ins> I plan to organise such events in the near future, so if you are interested do drop a message below</ins>.</p> <h4 id="architectural-decisions-records">Architectural Decisions Records</h4> <p>Logging architectural decisions enables people from an organisation to take further design decisions abiding to the agreed ones. It allows to have a place where one can fall back for referring to the previous decisions taken and get away from <a href="https://softwarearchitecturezen.blog/2010/01/27/architecture-anti-patterns-pattern-1-architecture-by-e-mail/">email driven architectural decisions</a>. To create a high level understanding, it is mandatory to refer to the older superseded decisions while creating new decisions. Having a standard template for such decisions helps to create standardised records. There are various open source tools as such <a href="https://github.com/npryce/adr-tools">adr-tools</a> to help align the ADRs process and become coherent with the software development process. Records could also include various types of pictorial diagrams, class diagram, state machines diagram, flow diagram etc, created with <a href="https://en.wikipedia.org/wiki/Unified_Modeling_Language">UMLs</a> to convey the idea effectively.</p> <h4 id="developing-your-unique-architectural-path">Developing your unique Architectural path</h4> <p>Becoming an effective architect is a time consuming process and requires detailed path planning. In the final concluding chapter the authors gave us useful tips on laying down the path to become an architect. Everybody’s path to become an architect is a unique one and hence there are no specific rules for it. Author suggested creating a personalised radar for the technologies we are interested in and to pay close attention to the developments in it. They have given a example of such radars which they create within their organisation called <a href="https://www.thoughtworks.com/en-de/radar">Technology Radar</a>.</p> <p>Hope this article gave you a good insight into the field of software architecture and what this book has to offer. Do drop me <a href="https://www.linkedin.com/in/piyushdjadhav/">a connect on linkedin</a> to get to know further updates from me such topics.</p> <p>Have a happy learning!</p>]]></content><author><name></name></author><category term="Architecture"/><category term="books"/><category term="Book-reviews,"/><category term="Architecture,"/><category term="Design"/><summary type="html"><![CDATA[Book review for Fundamentals of Software Architecture - Mark Richards and Neal Ford]]></summary></entry><entry><title type="html">Book Review For C++ Design Pattern</title><link href="https://piyja.github.io/blog/2024/Book-review-for-C++-Design-pattern/" rel="alternate" type="text/html" title="Book Review For C++ Design Pattern"/><published>2024-01-11T00:20:00+00:00</published><updated>2024-01-11T00:20:00+00:00</updated><id>https://piyja.github.io/blog/2024/Book-review-for-C++-Design-pattern</id><content type="html" xml:base="https://piyja.github.io/blog/2024/Book-review-for-C++-Design-pattern/"><![CDATA[<h1 id="about-the-book">About the book</h1> <p>Recently I got an opportunity to read C++ Software Design by Dr Klaus Iglberger. I find the concepts presented in the book if not to cover basics but quite intriguing to further the thought process. As a software developer, I do regularly of think of design patterns and use them aiming to make the codebase more modular, scalable, reusable, less coupled. Albeit I found a holistic view of the design patterns from this book and would recommend it to a seasoned software developer. In this post, I am aiming to give a summary of the book but it is not a promotional blog by any means. You can treat it as a nonexhaustive abstract of what the book covers but if you are intrigued more please dive into the book.</p> <p>The book is about 400 pages and is divided into 39 digestible guidelines. In my opinion, the best part about this book is the footnotes and further reading material the author provides us. If you have attended/heard Dr Klaus’s talks you can imagine his voice while reading the book. The author writes a lot about readers’ reactive comments while introducing the concepts, which might annoy few but also helps in covering all-around discussions on it. After going through some pages you can even anticipate when these takes are coming ;-)</p> <p>Alright, let’s dive in. Following are the sections giving the summary of the book.</p> <h1 id="13-basic-software-development-principles-and-what-they-mean-from-architectural-pov">[1/3] Basic Software Development principles and what they mean from architectural pov</h1> <p>In this first part of the book, the author introduces both what software design is and why it is important in any software project. If we go to the first principle it is nothing but the “Art of managing dependencies and abstraction”. The author represents software development in three levels of</p> <ol> <li>Software architecture</li> <li>Software design</li> <li>Implementation details</li> </ol> <p>and explains the differences in the architecture and design of the software. The author gives us a helpful perspective to look at any software designs, ie from high level (fairly stable) and low level (prone to change).</p> <p>The author emphasizes how <strong>change is constant</strong> and <strong>design for extension</strong> and we developers should persistently keep this in the back of our minds. The author covers the most famous software principles like SOLID, DRY, ISP (and many more) but more importantly there are discusssions on how to interpret these principles while creating the low-level designs of the software. Most of his takes boils down to a single aspect while creating the designs to think about the “separation of concerns”. Separation of concerns sits at the base for most of the design patterns, if I were to zoom into it further, separations of concerns can be thought of from these two lenses -</p> <ol> <li>Decreasing coupling (be it artificial coupling)</li> <li>Increasing cohesion</li> </ol> <p>The section <strong>Design for testability</strong> resurfaces the problems we often face while unit testing <em>badly</em> designed classes. The mitigation approach is to have white-boxed tested classes, which could be enough but is not the best approach for testing. Again the solution to this appeared to be in thinking of separating concerns at the early development stage.</p> <p>In the next section, the author takes us into the <strong>Art of building abstraction</strong> to effectively place the requirements and expectations into the code. In OOP-based languages, abstractions are usually built using base classes and also can be built using concepts (or equivalent). Many times these introduce more problems where we can use abstractions using free functions. This aspect is touched on in many ways later to show how we can achieve decoupling and separate concerns. Nevertheless, in all these forms of abstraction building it is important to adhere to LSP to forward the expectations correctly and DIP to think in terms of ownership of the introduced abstractions. Next the author talks about what purpose the design patterns serve - to provide a blueprint for the organizational software to be built upon. Naming design patterns with commonly known patterns helps to pass on intent and information to developers. The author again emphasizes that design patterns are not only limited to OOP or dynamic polymorphism, they can be very well extended to functional or generic programming.</p> <p>The open-for-extension guideline in OCP can be interpreted in two ways: open for extending types or open for extending operations. Procedural programming gives us ease of adding new code for extending the operations but gets tougher to add new polymorphic types. On the other hand with OOP, we get the ease of adding new polymorphic types but it is tougher or impossible for adding new operations without recompiling the base classes. In the early stage of the project, one must make a conscious decision about which path of extension he/she wants to follow. It is important to understand that no design fits all-purpose and has its advantages and disadvantages.</p> <h1 id="23-strategy-pattern-observer-and-crtp">[2/3] Strategy pattern, Observer and CRTP</h1> <p>Slowly the the design topics starts getting a bit complex.</p> <p>From the second tierce of the book, we start to get into various design patterns of both structural and behavioral patterns. First, we cover the visitor pattern and embrace it to solve our problems with the extension of operation in the inheritance hierarchy using double dispatch. Although naturally with this approach it gets tougher to add new types. We also learn that since we have double indirections used this design becomes quite inefficient by design. Next author introduces the std::variant style of visitor pattern, with which creating abstraction becomes quite easy. With std::variant we can group any unrelated types and based on the the type present at the call we can perform operations accordingly with the help of std::visit(). The new operations logic can be added on top without going back and changing any of these classes. While looking at the benchmarked result, it is worth mentioning that there are further nuances of these of writing your own get_if() functions to call particular operations based on the type provided. Refer the book to see various interesting benchmarks reported by the author.</p> <p>Then we move to cover the strategy pattern and command pattern. The strategy pattern intends to extend the polymorphic types of a class without much fuss. Strategy class can be thought of as serving complimentary aspect of open for extension as of visitor and also can be thought of as extracting the complex algorithms into separate entities being it a class or free function. Strategy entity can be injected as a dependency into the subject class. One of the downside in this pattern (also to be able to follow SRP) is that for each operation we need to add one strategy. One can use a <strong>Policy-based strategy design pattern</strong> by passing a policy in the form of a function object or lambda. We investigate the command design pattern next, which looks very similar and has the same implementation as that of the strategy design pattern. The only difference comes from the architectural point of view. For that matter even from the type of structural pattern, the adaptor design patterns strike as similar to strategy but the intent it serves is different. It becomes easy to think about the design when you think from the perspective of what intent they serve. We also cover differences in reference semantics (used often by OOP-based) and value-based designs. In this case, our policy-based designs emphasize the point of value-based semantics.</p> <p>Next, we go through the Adaptor pattern, the Observer pattern, and the CRTP pattern. Adaptor patterns are used to standardize the interfaces or to introduce a shim layer between the client and implementation details. Adaptors can be formed through creating an intermediate class or even by functions. Observer pattern is used where we require a notification system for a state change of the data, we are interested in. It creates a one-to-many relation between the subject (data we are interested in) and the observers. It is good to be aware of the further niche of this design: push observer and pull observer. It is also important to highlight that the observer pattern can be attained via value semantics as well. The CRTP pattern creates a compile-time abstraction for a family of related types. This is attained by using templates of the derived type, where we static cast this pointer to the derived class and access the methods we want to call. Note here since we use a template for the base class, we do not have the same base class for all derived types. C++20 concepts help us to implement this pattern.</p> <h1 id="33-bridge-prototype-and-type-erasure-pattern">[3/3] Bridge, prototype and type erasure pattern</h1> <p>The final third part of the book contains few of the most complex design patterns. If I were to go back referring to this book it would be mostly for this part of the book. The bridge pattern (belongs to the structural pattern domain ) can be used to isolate different concerns and bridge them. We can remove direct physical dependency between modules so that either end can evolve without affecting others (like retriggering recompilation etc.). The Pimpl Idiom is a more famous part of the bridge pattern. We can achieve ABI stability with this pattern. If we introduce more abstraction layers (and more indirections) it may appear that the efficiency could take a toll, which is true in most of the cases, but refer to the book to see where it can be even better than the unaltered design.</p> <p>The prototype pattern is used to self-clone concrete types from its base class object pointer. It is equivalent to having a virtual copy constructor. External polymorphism is a non-intrusive method to lets the user use the non-related (no-inheritance) classes to be treated polymorphically. There are new terms like concepts class (base) and model classes (derived from concept class) used. The important thing to know is that for different types of classes, there are different base classes (which could be templatized). This pattern takes advantage of it being non-polymorphic (fewer indirections), can be easily extendable according to OCP, and follows DRY and DIP. However, this pattern does not follow value semantics.</p> <p>The intent of the type erasure design pattern is to provide value-based non-intrusive abstraction for unrelated types but with the same semantic behavior. The type erasure design pattern contains a combination of external polymorphism, bridge pattern, and potentially prototype design pattern. It got its name because of the fact that the abstract class does not store the information about the concrete type of the object hence the type is erased. The author also adds optimization techniques like using SBO instead of dynamic memory to allocate and deallocate memory or manual dispatch instead of virtual table indirections.</p> <p>Decorator pattern allows dynamically attaching new functionality to the existing types without changing the types. In other words, it is a flexible alternative to subclassing for extending functionality. The author tells the reference from the GoF book about how the analogy of strategy being the gut of the object and decorator being the skin. The author also gave a quick tour of the Singleton pattern. Singleton pattern is infamous for the issues with SIOF, hindrance to testability, etc. The author shows us how strategy patterns could be used to invert dependency of the singleton pattern easily for testability.</p> <p>I hope you enjoyed reading this summarisation and find it helpful. If you decide to read the book do enjoy it! If you have already read the book, let me know if you have something more to add.</p> <h1 id="abbreviations">Abbreviations:</h1> <ul> <li>OOP: Object Oriented Programming</li> <li>DRY: Do Not Repeat yourself</li> <li>SOLID: 5 most famous software programming principle next in line -</li> <li>SRP: Sinogle Responsibility Principle</li> <li>OCP : Open Close Principle</li> <li>LSP: Liskov’s Substitution Principle</li> <li>ISP: Interface Segregation Principle</li> <li>DIP: Dependency Inversion Principle</li> <li>CRTP: Curiously Recurring Template Pattern</li> <li>SBO: Small buffer optimization</li> <li>SIOF: Static initialization order fiasco</li> <li>GoF: Gang of four book - Design Patterns: Elements of Reusable Object-oriented software</li> </ul>]]></content><author><name></name></author><category term="Design"/><category term="books"/><category term="Design,"/><category term="Book-reviews,"/><category term="C++"/><summary type="html"><![CDATA[Book-review for C++ Design pattern – Klaus Iglberger]]></summary></entry></feed>